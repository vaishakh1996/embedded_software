/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>



#include <stdint.h>

#define RCC_BASE       0x40021000UL
#define FLASH_BASE     0x40022000UL
#define GPIOA_BASE     0x40010800UL

#define RCC_CR         (*(volatile uint32_t *)(RCC_BASE + 0x00))
#define RCC_CFGR       (*(volatile uint32_t *)(RCC_BASE + 0x04))
#define RCC_APB2ENR    (*(volatile uint32_t *)(RCC_BASE + 0x18))

#define FLASH_ACR      (*(volatile uint32_t *)(FLASH_BASE + 0x00))

#define GPIOA_CRL      (*(volatile uint32_t *)(GPIOA_BASE + 0x00))
#define GPIOA_BSRR     (*(volatile uint32_t *)(GPIOA_BASE + 0x10))

void SYSCLK_init(void) {
    // Enable HSE (bit 16)
    RCC_CR |= (1 << 16);
    while ((RCC_CR & (1 << 17)) == 0); // Wait for HSERDY (bit17)

    // Enable Prefetch buffer and set flash latency to 1 WS
    FLASH_ACR |= (1 << 4);
    FLASH_ACR &= ~(7 << 0);
    FLASH_ACR |= 1 << 0;

    // Clear PLLSRC and PLLMUL bits
    RCC_CFGR &= ~((1 << 16) | (0xF << 18));

    // Set PLLSRC = HSE (bit 16)
    RCC_CFGR |= (1 << 16);

    // Set PLLMUL to x4 (0x2 shifted to bits 21:18)
    RCC_CFGR |= (0x2 << 18);

    // Set AHB prescaler HPRE bits [7:4] to SYSCLK not divided (0b0000)
    RCC_CFGR &= ~(0xF << 4); // clear bits 4-7

    // Set APB1 low-speed prescaler PPRE1 bits [10:8] to divide by 2 (0b100)
    RCC_CFGR &= ~(0x7 << 8); // clear bits 8-10
    RCC_CFGR |= (0x4 << 8);  // set to divide by 2: 0b100

    // Set APB2 high-speed prescaler PPRE2 bits [13:11] to not divided (0b000)
    RCC_CFGR &= ~(0x7 << 11); // clear bits 11-13

    // Enable PLL (bit 24)
    RCC_CR |= (1 << 24);
    while ((RCC_CR & (1 << 25)) == 0); // Wait for PLLRDY (bit 25)

    // Select PLL as system clock: clear SW bits [1:0], set to 0b10
    RCC_CFGR &= ~(0x3);
    RCC_CFGR |= 0x2;
    while ((RCC_CFGR & (0x3 << 2)) != (0x2 << 2)); // Wait for SWS bits [3:2] == 0b10 (PLL)
}



void delay(volatile uint32_t count) {
    while (count--) {}
}

int main(void) {
    SYSCLK_init();

    // Enable GPIOA clock, IOPAEN is bit 2 in RCC_APB2ENR
    RCC_APB2ENR |= (1 << 2);

    // Configure PA5 (pin 5) as output push-pull, 2 MHz
    // CRL controls pins 0..7, 4 bits per pin
    // Clear bits 23:20 for PA5
    GPIOA_CRL &= ~(0xF << (5 * 4));
    // Set MODE5=0b10 (bits 21:20), CNF5=0b00 (bits 23:22)
    GPIOA_CRL |= (0x6 << (5 * 4)); // MODE5 = 10 (2 MHz output)
    // CNF5 already clear for push-pull

    while (1) {
        GPIOA_BSRR = (1 << 5);          // Set PA5 high
        delay(500000);
        //GPIOA_BSRR = (1 << (5 + 16));  // Reset PA5 low
        delay(500000);
    }
}
