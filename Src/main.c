/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <peripherals.h>


void SYSCLK_init(void);
void delay(volatile uint32_t count);




int main(void) {
    SYSCLK_init();

    // Enable GPIOA clock, IOPAEN is bit 2 in RCC_APB2ENR
    RCC_APB2ENR |= (1 << 2);

    // Configure PA5 (pin 5) as output push-pull, 2 MHz
    // CRL controls pins 0..7, 4 bits per pin
    // Clear bits 23:20 for PA5
    GPIOA_CRL &= ~(0xF << (5 * 4));
    // Set MODE5=0b10 (bits 21:20), CNF5=0b00 (bits 23:22)
    GPIOA_CRL |= (0x2 << (5 * 4)); // MODE5 = 10 (2 MHz output)
    // CNF5 already clear for push-pull

    while (1) {
        GPIOA_BSRR = (1 << 5);          // Set PA5 high
        delay(500000);
        GPIOA_BSRR = (1 << (5 + 16));  // Reset PA5 low
        delay(500000);
    }
}

void SYSCLK_init(void) {
    // 1Ô∏è‚É£ Enable HSE (High-Speed External, typically 8 MHz)
    RCC_CR |= (1 << 16);
    while ((RCC_CR & (1 << 17)) == 0); // Wait for HSERDY
    // HSE frequency = 8 MHz

    // 2Ô∏è‚É£ Enable Prefetch buffer and set flash latency to 1 WS
    FLASH_ACR |= (1 << 4);
    FLASH_ACR &= ~(7 << 0);
    FLASH_ACR |= 1 << 0;
    // Flash latency set for SYSCLK > 24 MHz (required for 32 MHz)
    // Prefetch buffer enabled for better performance

    // 3Ô∏è‚É£ Clear PLLSRC and PLLMUL bits
    RCC_CFGR &= ~((1 << 16) | (0xF << 18));

    // 4Ô∏è‚É£ Set PLLSRC = HSE (bit 16)
    RCC_CFGR |= (1 << 16);
    // PLL input clock = HSE = 8 MHz

    // 5Ô∏è‚É£ Set PLLMUL to x4 (0x2 shifted to bits 21:18)
    RCC_CFGR |= (0x2 << 18);
    // PLL multiplication factor = 4
    // PLL output = 8 MHz * 4 = 32 MHz

    // 6Ô∏è‚É£ Set AHB prescaler HPRE bits [7:4] to SYSCLK not divided (0b0000)
    RCC_CFGR &= ~(0xF << 4); // clear bits 4-7
    // AHB clock (HCLK) = SYSCLK / 1 = 32 MHz

    // 7Ô∏è‚É£ Set APB1 low-speed prescaler PPRE1 bits [10:8] to divide by 2 (0b100)
    RCC_CFGR &= ~(0x7 << 8); // clear bits 8-10
    RCC_CFGR |= (0x4 << 8);  // set to divide by 2
    // APB1 clock (PCLK1) = HCLK / 2 = 32 MHz / 2 = 16 MHz
    // Note: Max APB1 frequency is 36 MHz, safe

    // 8Ô∏è‚É£ Set APB2 high-speed prescaler PPRE2 bits [13:11] to not divided (0b000)
    RCC_CFGR &= ~(0x7 << 11); // clear bits 11-13
    // APB2 clock (PCLK2) = HCLK / 1 = 32 MHz

    // 9Ô∏è‚É£ Enable PLL (bit 24)
    RCC_CR |= (1 << 24);
    while ((RCC_CR & (1 << 25)) == 0); // Wait for PLLRDY
    // PLL output = 32 MHz (ready to use as system clock)

    // üîü Select PLL as system clock: clear SW bits [1:0], set to 0b10
    RCC_CFGR &= ~(0x3);
    RCC_CFGR |= 0x2;
    while ((RCC_CFGR & (0x3 << 2)) != (0x2 << 2)); // Wait for SWS bits [3:2] == 0b10 (PLL)
    // System clock (SYSCLK) = PLL output = 32 MHz
}



void delay(volatile uint32_t count) {
    while (count--) {}
}
