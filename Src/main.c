/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <peripherals.h>


void SYSCLK_init(void);
void Timer2_Init(void);
void delay_ms(uint32_t ms);




int main(void) {
    SYSCLK_init();
    Timer2_Init();

    // Enable GPIOA clock, IOPAEN is bit 2 in RCC_APB2ENR
    RCC_APB2ENR |= (1 << 2);

    // Configure PA5 (pin 5) as output push-pull, 2 MHz
    // CRL controls pins 0..7, 4 bits per pin
    // Clear bits 23:20 for PA5
    GPIOA_CRL &= ~(0xF << (5 * 4));
    // Set MODE5=0b10 (bits 21:20), CNF5=0b00 (bits 23:22)
    GPIOA_CRL |= (0x2 << (5 * 4)); // MODE5 = 10 (2 MHz output)
    // CNF5 already clear for push-pull

    while (1) {
        GPIOA_BSRR = (1 << 5);          // Set PA5 high
        delay_ms(1000);
        GPIOA_BSRR = (1 << (5 + 16));  // Reset PA5 low
        delay_ms(1000);
    }
}

void SYSCLK_init(void) {
    // 1Ô∏è‚É£ Enable HSE (High-Speed External, typically 8 MHz)
    RCC_CR |= (1 << 16);
    while ((RCC_CR & (1 << 17)) == 0); // Wait for HSERDY
    // HSE frequency = 8 MHz

    // 2Ô∏è‚É£ Enable Prefetch buffer and set flash latency to 1 WS
    FLASH_ACR |= (1 << 4);
    FLASH_ACR &= ~(7 << 0);
    FLASH_ACR |= 1 << 0;
    // Flash latency set for SYSCLK > 24 MHz (required for 32 MHz)
    // Prefetch buffer enabled for better performance

    // 3Ô∏è‚É£ Clear PLLSRC and PLLMUL bits
    RCC_CFGR &= ~((1 << 16) | (0xF << 18));

    // 4Ô∏è‚É£ Set PLLSRC = HSE (bit 16)
    RCC_CFGR |= (1 << 16);
    // PLL input clock = HSE = 8 MHz

    // 5Ô∏è‚É£ Set PLLMUL to x4 (0x2 shifted to bits 21:18)
    RCC_CFGR |= (0x2 << 18);
    // PLL multiplication factor = 4
    // PLL output = 8 MHz * 4 = 32 MHz

    // 6Ô∏è‚É£ Set AHB prescaler HPRE bits [7:4] to SYSCLK not divided (0b0000)
    RCC_CFGR &= ~(0xF << 4); // clear bits 4-7
    // AHB clock (HCLK) = SYSCLK / 1 = 32 MHz

    // 7Ô∏è‚É£ Set APB1 low-speed prescaler PPRE1 bits [10:8] to divide by 2 (0b100)
    RCC_CFGR &= ~(0x7 << 8); // clear bits 8-10
    RCC_CFGR |= (0x4 << 8);  // set to divide by 2
    // APB1 clock (PCLK1) = HCLK / 2 = 32 MHz / 2 = 16 MHz
    // Note: Max APB1 frequency is 36 MHz, safe

    // 8Ô∏è‚É£ Set APB2 high-speed prescaler PPRE2 bits [13:11] to not divided (0b000)
    RCC_CFGR &= ~(0x7 << 11); // clear bits 11-13
    // APB2 clock (PCLK2) = HCLK / 1 = 32 MHz

    // 9Ô∏è‚É£ Enable PLL (bit 24)
    RCC_CR |= (1 << 24);
    while ((RCC_CR & (1 << 25)) == 0); // Wait for PLLRDY
    // PLL output = 32 MHz (ready to use as system clock)

    // üîü Select PLL as system clock: clear SW bits [1:0], set to 0b10
    RCC_CFGR &= ~(0x3);
    RCC_CFGR |= 0x2;
    while ((RCC_CFGR & (0x3 << 2)) != (0x2 << 2)); // Wait for SWS bits [3:2] == 0b10 (PLL)
    // System clock (SYSCLK) = PLL output = 32 MHz
}

void Timer2_Init(void) {
    // 1. Enable clock for Timer 2 (bit 0 in RCC_APB1ENR)
    RCC_APB1ENR |= (1 << 0);

    // 2. Set prescaler for 1 kHz timer clock assuming 2 * 16 MHz APB1 clock
    TIM2_PSC = 31999;  // divides 32 MHz by (31999 + 1)  = 1 kHz timer frequency

    // 3. Set auto-reload register for max count
    TIM2_ARR = 0xFFFF; // Max 16-bit value

    // 4. Enable the timer by setting CEN bit (counter enable) to start counting up
    TIM2_CR1 |= (1 << 0);
}


void delay_ms(uint32_t ms) {
	TIM2_CR1 &= ~(1 << 0);       // Disable timer (CEN=0)
	TIM2_CNT = 0;                // Reset counter
	TIM2_EGR = 1;                // Generate update event (UG=1)
	TIM2_CR1 |= (1 << 0);        // Enable timer (CEN=1)
       // Start timer
    while (TIM2_CNT < ms) {
        // Wait until desired count reached
    }
    TIM2_CR1 &= ~(1 << 0);        // Stop timer (optional)
}


